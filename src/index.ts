import { parse } from 'node-html-parser'

import type { KVNamespace, ExecutionContext } from '@cloudflare/workers-types'

const SECURITY_PAGE = 'https://support.apple.com/en-us/HT201222'
const STRING = /exploited/

export default {
  async fetch(
    req: Request,
    env: {
      TOKEN: string
      STORE: KVNamespace
    },
    _ctx: ExecutionContext
  ): Promise<Response> {
    if (!req.body) return new Response('no body')

    const data = await req.json()

    // Something about us changed
    if (data?.my_chat_member) {
      const myInfo = data.my_chat_member
      const chatId = myInfo.chat.id as number
      const newStatus = myInfo.new_chat_member.status

      const addedStatuses = ['creator', 'administrator', 'member']
      const removedStatuses = ['restricted', 'left', 'kicked']

      // We are added
      if (addedStatuses.includes(newStatus)) {
        console.log(`adding ${chatId} to chats`)

        const chats = (await env.STORE.get('chats')) ?? '[]'
        const chatsParsed = JSON.parse(chats) as number[]

        const newChats = [...chatsParsed, chatId]

        await env.STORE.put('chats', JSON.stringify(newChats))
      }
      // We are removed
      else if (removedStatuses.includes(newStatus)) {
        console.log(`removing ${chatId} from chats`)

        const chats = await env.STORE.get('chats')
        if (!chats) return new Response('no chats yet')
        const chatsParsed = JSON.parse(chats) as number[]

        const chatsFiltered = chatsParsed.filter(
          (existingId) => existingId !== chatId
        )

        await env.STORE.put('chats', JSON.stringify(chatsFiltered))
      }
    }

    return new Response('done')
  },
  async scheduled(
    _req: Request,
    env: {
      TOKEN: string
      STORE: KVNamespace
    },
    _ctx: ExecutionContext
  ): Promise<Response> {
    const BOT = `https://api.telegram.org/bot${env.TOKEN}`

    const chats = await env.STORE.get('chats')

    if (!chats) return new Response('no chats yet')

    const chatsParsed = JSON.parse(chats) as number[]

    const sendMessage = async (
      text: string,
      options?: { [key: string]: unknown }
    ) => {
      for (const chat of chatsParsed) {
        const body = {
          chat_id: chat,
          text,
          ...options,
        }

        const req = await fetch(`${BOT}/sendMessage`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        })

        if (!req.ok) {
          console.log(await req.json())
        }
      }
    }

    const req = await fetch(SECURITY_PAGE)
    const res = await req.text()

    if (!req.ok) {
      console.log(res)
      return new Response('failed to load main support page')
    }

    const parsed = parse(res)

    const rows = parsed.querySelectorAll('tr').slice(1) // without heading row

    // Rows: name with optional link - description - date
    for (const row of rows.slice(0, 10)) {
      const link = row.querySelector('a')
      const [name, descr, date] = row
        .querySelectorAll('td')
        // biome-ignore lint: must have a child per html markup
        .map((x) => x.firstChild!.innerText)

      if (link) {
        const href = link.attributes.href.toString()
        const isProcessed = await env.STORE.get(href)
        if (isProcessed) continue

        // biome-ignore lint: trust me, this is nicer
        const req = await fetch('https://support.apple.com' + href)
        const res = await req.text()

        if (!req.ok) {
          console.log(res)
          return new Response('failed to load individual support page')
        }

        const isExploited = STRING.test(res)

        if (isExploited) {
          await sendMessage(
            [
              'Update with a fix for an actively exploited vuln(s):',
              name,
              '', // spacer
              'For:',
              descr,
              '', // spacer
              'Released:',
              date,
              '', // spacer
              `<a href="${href}">Support Document</a>`,
            ].join('\n'),
            { parse_mode: 'HTML' }
          )
        }

        await env.STORE.put(href, 'done')
      }
    }

    return new Response('done')
  },
}
